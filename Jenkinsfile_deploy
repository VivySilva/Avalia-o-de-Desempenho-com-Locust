pipeline {
  agent any
  
  stages {
    stage('Checkout Configuration') {
      steps {
        script {
          // Chỉ checkout main để lấy file cấu hình Kubernetes
          git branch: 'PR-4', 
              url: 'https://github.com/tranductung07012004/devOps_1_spring-petclinic-microservices.git'
        }
      }
    }

    stage('Setup Kubernetes Namespace') {
      steps {
        script {
          sh '''
            kubectl version --client
            kubectl get namespace petclinic-dev || kubectl create namespace petclinic-dev
          '''
        }
      }
    }

    stage('Deploy to Kubernetes') {
      steps {
        script {
          def services = [
              ['name': 'customers-service', 'paramName': 'customers-service'],
              ['name': 'genai-service', 'paramName': 'genai-service'],
              ['name': 'vets-service', 'paramName': 'vets-service'],
              ['name': 'visits-service', 'paramName': 'visits-service']
          ]
          
          withCredentials([usernamePassword(credentialsId: 'docker_hub_PAT', usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
              sh "docker login -u ${DOCKER_USERNAME} -p ${DOCKER_PASSWORD}"
              
              for (service in services) {
                def branchValue = params[service.paramName] ?: 'main'
                def serviceTag = 'latest'
                
                // Nếu không phải branch main, lấy commitId mới nhất của branch đó
                if (branchValue != 'main') {
                  // Lấy commitId mới nhất của branch không cần checkout
                  def commitOutput = sh(
                    script: "git ls-remote https://github.com/tranductung07012004/devOps_1_spring-petclinic-microservices.git refs/heads/${branchValue}",
                    returnStdout: true
                  ).trim()
                  
                  // Nếu branch tồn tại
                  if (commitOutput) {
                    // Extract commitId (lấy 7 ký tự đầu của SHA)
                    serviceTag = commitOutput.split()[0].substring(0, 7)
                    echo "Using tag ${serviceTag} for ${service.name} from branch ${branchValue}"
                  } else {
                    echo "WARNING: Branch ${branchValue} not found. Using 'latest' tag for ${service.name}"
                  }
                }
                
                // Deploy with the determined tag
                sh """
                cat k8s/${service.name}.yaml | sed 's/\${IMAGE_TAG}/${serviceTag}/g' | sed 's/\${DOCKER_USERNAME}/${DOCKER_USERNAME}/g' > k8s/${service.name}-temp.yaml
                kubectl apply -f k8s/${service.name}-temp.yaml
                rm k8s/${service.name}-temp.yaml
                """
                
                // Wait for deployment to be available
                sh "kubectl wait --for=condition=available deployment/${service.name} -n petclinic-dev --timeout=60s || echo 'Warning: Deployment may not be ready'"
              }
            }
            
            // Apply Ingress configuration
            sh "kubectl apply -f k8s/petclinic-ingress.yaml"
            
            echo "Services deployed successfully to http://petclinic.local/"
        }
      }
    }
  }
  
  post {
        success {
            script {
                def commitId = env.GIT_COMMIT
                echo "Sending 'success' status to GitHub for commit: ${commitId}"
                def response = httpRequest(
                    url: "https://api.github.com/repos/tranductung07012004/devOps_1_spring-petclinic-microservices/statuses/${commitId}",
                    httpMode: 'POST',
                    contentType: 'APPLICATION_JSON',
                    requestBody: """{
                        "state": "success",
                        "description": "Deploy passed",
                        "context": "CD/jenkins_deploy-pipeline",
                        "target_url": "${env.BUILD_URL}"
                    }""",
                    authentication: 'github-token-fix'
                )
                echo "GitHub Response: ${response.status}"
            }
        }

        failure {
            script {
                def commitId = env.GIT_COMMIT
                echo "Sending 'failure' status to GitHub for commit: ${commitId}"
                def response = httpRequest(
                    url: "https://api.github.com/repos/tranductung07012004/devOps_1_spring-petclinic-microservices/statuses/${commitId}",
                    httpMode: 'POST',
                    contentType: 'APPLICATION_JSON',
                    requestBody: """{
                        "state": "failure",
                        "description": "Deploy failed",
                        "context": "cd/jenkins_deploy-pipeline",
                        "target_url": "${env.BUILD_URL}"
                    }""",
                    authentication: 'github-token-fix'
                )
                echo "GitHub Response: ${response.status}"
            }
        }

        always {
            echo "Pipeline finished."
        }
    }
}